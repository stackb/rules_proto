GoModuleInfo = provider(
    doc = "info about a go_module",
    fields = {
        "output_file": "[File] the go.mod output file",
        "label": "[Label]: the label of the originating rule",
        "importpath": "[String] the module importpath",
    },
)

def _go_module_impl(ctx):
    output_file = ctx.actions.declare_file("go.mod")

    inputs = ctx.files.srcs

    ctx.actions.run_shell(
        mnemonic = "WriteGoModule",
        inputs = inputs,
        outputs = [output_file],
        command = """echo 'module {importpath}\ngo {version}' > {output_file}""".format(
            importpath = ctx.attr.importpath,
            version = ctx.attr.go_version,
            output_file = output_file.path,
        ),
    )

    return [
        DefaultInfo(files = depset([output_file])),
        GoModuleInfo(
            output_file = output_file,
            label = ctx.label,
            importpath = ctx.attr.importpath,
        ),
    ]

go_module = rule(
    implementation = _go_module_impl,
    attrs = {
        "importpath": attr.string(
            doc = "go importpath",
            mandatory = True,
        ),
        "go_version": attr.string(
            doc = "go version",
            default = GO_VERSION,
        ),
        "srcs": attr.label_list(
            doc = "generated sources included in the module",
            allow_files = True,
        ),
    },
    provides = [DefaultInfo, GoModuleInfo],
)

def _go_modules_impl(ctx):
    replacements_file = ctx.outputs.replacements
    script_file = ctx.outputs.script

    module_files = [
        dep[GoModuleInfo].output_file
        for dep in ctx.attr.deps
    ]

    begin_marker = "// BEGIN: generated by: bazel run %s" % ctx.label
    end_marker = "// END: generated by: bazel run %s" % ctx.label

    require_lines = ["require ("] + [
        "\t%s v0.0.0-00010101000000-000000000000" % dep[GoModuleInfo].importpath
        for dep in ctx.attr.deps
    ] + [")"]

    replacement_lines = ["replace ("] + [
        "\t%s => ./bazel-bin/%s" % (dep[GoModuleInfo].importpath, dep[GoModuleInfo].label.package)
        for dep in ctx.attr.deps
    ] + [")"]

    all_lines = [begin_marker] + require_lines + [""] + replacement_lines + [end_marker]

    ctx.actions.run_shell(
        mnemonic = "WriteGoModuleReplacements",
        outputs = [replacements_file],
        inputs = module_files,
        command = "echo '%s' > %s" % ("\n".join(all_lines), replacements_file.path),
    )

    ctx.actions.expand_template(
        template = ctx.file._script_template,
        output = script_file,
        substitutions = {
            "{content}": "\n".join(all_lines),
        },
        is_executable = True,
    )

    return [
        DefaultInfo(
            executable = script_file,
            files = depset([script_file, replacements_file] + module_files),
        ),
    ]

go_modules = rule(
    implementation = _go_modules_impl,
    attrs = {
        "deps": attr.label_list(
            doc = "data dependencies to be built from this one",
            providers = [GoModuleInfo],
        ),
        "_script_template": attr.label(
            doc = "template for the go.mod replacement script",
            default = Label("//bazel_tools:go_mod_replacements.sh.tmpl"),
            allow_single_file = True,
        ),
    },
    outputs = {
        "replacements": "%{name}.replacements",
        "script": "%{name}.sh",
    },
    provides = [DefaultInfo],
    executable = True,
)
